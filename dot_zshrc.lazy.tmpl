# cSpell:disable
#--------------------------------------------------------------
# path , alias
#--------------------------------------------------------------

{{ if eq .chezmoi.os "darwin" -}}
path=(
  /opt/homebrew/opt/coreutils/libexec/gnubin(N)
  /opt/homebrew/opt/findutils/libexec/gnubin(N)
  /opt/homebrew/opt/grep/libexec/gnubin(N)
  /opt/homebrew/opt/gnu-sed/libexec/gnubin(N)
  $path
)
{{- end }}

alias gb='git branch'
alias gf='git fetch -p'
alias ll='ls -l'
alias la='ls -la'
alias mh='make help'
alias nr='npm run'

#--------------------------------------------------------------
# plugin
#--------------------------------------------------------------

# wait = 遅延読み込み wait"0"と同義
# lucid = プラグイン読込時の表示をOFF
# blockf = プラグインによる$pathの変更を禁止する
# light-mode = for構文におけるzinit light(light-modeがない場合はzinit snippet相当)
# as"program" = zshプラグインでないものを読込(ソースを$pathに追加)
# as"completion" = 補完プラグインとして追加
# from = clone先を指定 [from"github"(デフォルト)/from"gh-r"(Github Release)]
# bpick= gh-rするファイル名を指定 [例.bpick"nnn-v*"]
# mv = ファイルをmv
# cp = ファイルをcp
# atclone= clone後に実行する関数を指定
# atpull= pull後(upgrade)に実行する関数を指定 [atpull"%atclone" = atcloneの内容を実行]
# make= make install
# rustup = rust installer
# cargo = rust builder and package manager
# (plugin script loading)
# src = 読込完了時に指定ファイル読込
# atload = 読込完了時に実行する関数を指定
# pick = 引数に与えられたものを$pathに追加
# sbin = 引数に与えられたものを$pathに追加

### command ###

# asdf #
__asdf_atload() {
    export ASDF_DATA_SHIMS="$HOME/.asdf/shims"
    export ASDF_DATA_INSTALLS="$HOME/.asdf/installs"
    export ASDF_CONFIG_FILE="$HOME/.config/asdf/.asdfrc"
    export PATH="$ASDF_DATA_SHIMS:$ASDF_DATA_INSTALLS:$PATH"
}
zinit wait lucid light-mode blockf for \
    src"asdf.sh" \
    atload"__asdf_atload" \
    @'asdf-vm/asdf'

# atuin #
__atuin_atload() {
    eval "$(atuin init zsh --disable-up-arrow --disable-ctrl-r)"
    export ATUIN_CONFIG_DIR="$HOME/.config/atuin"
}
zinit wait lucid light-mode blockf for \
    from"gh-r" rustup cargo"atuin" \
    sbin"atuin*/atuin" \
    atclone"atuin gen-completions --shell zsh > _atuin" atpull"%atclone" \
    atload"__atuin_atload" \
    ellie/atuin

# bat #
__bat_atload() {
    export BAT_THEME="Monokai Extended"
}
zinit wait lucid light-mode blockf for \
    from"gh-r" \
    sbin"bat*/bat" \
    cp"bat*/autocomplete/bat.zsh -> _bat" \
    atload"__bat_atload" \
    @'sharkdp/bat'

# Clipboard #
__clipboard_atload() {
    export CLIPBOARD_SILENT=1
}
zinit wait lucid light-mode blockf for \
    from"gh-r" \
    sbin"bin/cb" \
    atload"__clipboard_atload" \
    @'Slackadays/Clipboard'

# delta #
zinit wait lucid light-mode blockf for \
    from"gh-r" \
    sbin"delta*/delta" \
    atload"compdef _gnu_generic delta" \
    @'dandavison/delta'

# dura #
zinit wait lucid light-mode blockf for \
    cargo"dura" \
    sbin"bin/dura" \
    @'tkellogg/dura'

# fzf #
__fzf_atload() {
    export FZF_DEFAULT_COMMAND='find $PWD -type d -path "$PWD/.*" -prune -o -not -name ".*" -type f -name "*" -print'
    export FZF_DEFAULT_OPTS='-m --height 40% --layout=reverse --border'
}
zinit wait lucid light-mode blockf for \
    from"gh-r" \
    sbin"fzf" \
    atload"__fzf_atload" \
    junegunn/fzf
zinit wait lucid blockf for \
    "https://github.com/junegunn/fzf/blob/master/shell/key-bindings.zsh" \
    "https://github.com/junegunn/fzf/blob/master/shell/completion.zsh"

# ghq #
zinit wait lucid light-mode blockf for \
    from"gh-r" \
    sbin"*/ghq" \
    @'x-motemen/ghq'

# gitui #
zinit wait lucid light-mode blockf for \
    from"gh-r" cargo"gitui" \
    sbin"gitui" \
    @'extrawurst/gitui'

# github-cli #
zinit wait lucid light-mode blockf for \
    from"gh-r" \
    sbin"gh*/bin/gh" \
    atclone"./gh*/bin/gh completion -s zsh >_gh" atpull"%atclone" \
    @'cli/cli'

# git-jump #
zinit wait lucid light-mode blockf for \
    as"program" pick"git-jump" \
    "https://github.com/git/git/blob/master/contrib/git-jump/git-jump"

# jq #
zinit wait lucid light-mode blockf for \
    from"gh-r" bpick"jq-osx-*" \
    sbin"jq* -> jq" \
    @'jqlang/jq'

# navi #
# atload"eval $(navi widget zsh)" \
__navi_atclone() {
    ln -s ~/.config/navi/config.yaml "$(navi info config-path)"
}
zinit wait lucid light-mode blockf for \
    from"gh-r" cargo"navi" \
    sbin"navi" \
    atclone"__navi_atclone" \
    denisidoro/navi

# up #
zinit wait lucid light-mode blockf for \
    from"gh-r" \
    sbin"up-darwin -> up" \
    @'akavel/up'

# yazi #
zinit wait lucid light-mode blockf for \
    from"gh-r" cargo"yazi" \
    sbin"yazi* -> yazi" \
    @'sxyazi/yazi'

# z #
#__z_atload() {
#    export _Z_DATA="$HOME/.local/state/z/.z"
#}
#zinit wait lucid light-mode blockf for \
#    as"program" pick"z" \
#    src"z.sh" cp"z.sh -> z" \
#    atload"__z_atload" \
#    rupa/z

# zoxide #
__zoxide_atload() {
    export _ZO_DATA_DIR="$HOME/.local/state/zoxide"
    eval "$(zoxide init zsh)"
}
zinit wait lucid light-mode blockf for \
    from"gh-r" \
    sbin"zoxide" \
    atload"__zoxide_atload" \
    @'ajeetdsouza/zoxide'

{{ if eq .chezmoi.os "darwin" -}}
# blueutil #
zinit wait lucid light-mode blockf for \
    make \
    sbin"blueutil" \
    @'toy/blueutil'
{{- end }}

### node ###
zinit wait lucid light-mode blockf for \
    node"!cspell -> cspell" \
    node"!czg -> czg" \
    node"!open-cli -> open-cli" \
    z-shell/0

### plugin ###
__zsh-autosuggestions_atload() {
    ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=100"
    _zsh_autosuggest_start
}
zinit wait lucid light-mode blockf for \
    atload"__zsh-autosuggestions_atload" \
    zsh-users/zsh-autosuggestions

zinit wait lucid light-mode blockf for \
    atload"source autopair.zsh && autopair-init" \
    hlissner/zsh-autopair

zinit wait lucid light-mode blockf for \
    olets/zsh-abbr \
    zdharma/fast-syntax-highlighting

### completion ###

zinit wait lucid light-mode blockf for \
    as"completion" \
    atload"zicompinit; zicdreplay" cp"git-completion.zsh -> _git" \
    "https://github.com/git/git/blob/master/contrib/completion/git-completion.zsh"

zinit wait lucid light-mode blockf for \
    silent \
    atclone"zstyle ':completion:*:*:git:*' script git-completion.bash" atpull"%atclone" \
    "https://github.com/git/git/blob/master/contrib/completion/git-completion.bash"

zinit wait lucid light-mode blockf for \
    as"completion" "https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker" \
    as"completion" "https://raw.githubusercontent.com/docker/compose/1.29.2/contrib/completion/zsh/_docker-compose" \
    as"completion" "https://github.com/Homebrew/brew/blob/master/completions/zsh/_brew"

zinit wait lucid light-mode blockf for \
    src"tmux" \
    as"completion" "https://github.com/imomaliev/tmux-bash-completion/blob/master/completions/tmux"

zinit wait lucid light-mode blockf for \
    atload"source zsh-better-npm-completion.plugin.zsh" \
    as"completion" "https://github.com/lukechilds/zsh-better-npm-completion/blob/master/zsh-better-npm-completion.plugin.zsh"

#--------------------------------------------------------------
# fzf-function
#--------------------------------------------------------------

{{ if eq .chezmoi.os "darwin" -}}
# fcb - fuzzy chrome bookmark
fcb() {
  bookmarks_path="$HOME/Library/Application Support/Google/Chrome/Profile 1/Bookmarks"

  jq_script='
    def ancestors: while(. | length >= 2; del(.[-1,-2]));
    . as $in | paths(.url?) as $key | $in | getpath($key) | {name,url, path: [$key[0:-2] | ancestors as $a | $in | getpath($a) | .name?] | reverse | join("/") } | .path + "/" + .name + "\t" + .url'

  jq -r "$jq_script" < "$bookmarks_path" \
    | sed -E $'s/(.*)\t(.*)/\\1\t\x1b[36m\\2\x1b[m/g' \
    | fzf --ansi \
    | cut -d$'\t' -f2 \
    | xargs open
}

# fch - fuzzy chrome history
fch() {
  local cols sep google_history open
  cols=$(( COLUMNS / 3 ))
  sep='{::}'

  if [ "$(uname)" = "Darwin" ]; then
    google_history="$HOME/Library/Application Support/Google/Chrome/Profile 1/History"
    open=open
  else
    google_history="$HOME/.config/google-chrome/Profile 1/History"
    open=xdg-open
  fi
  cp -f "$google_history" /tmp/h
  sqlite3 -separator $sep /tmp/h \
    "select substr(title, 1, $cols), url
     from urls order by last_visit_time desc" |
  awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
  fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open > /dev/null 2> /dev/null
}
{{- end }}

# ff - fuzzy find
ff() {
  find ${1:-.} | fzf | tr -d '\n'| cb
}

# fgb - fuzzy git branch
fgb() {
  git for-each-ref --format='%(refname:short) %09 %(committername) %09 %(committerdate:format:%Y/%m/%d %H:%M) %09 %(objectname:short)' --sort=-committerdate | column -ts $'\t' | fzf | awk '{ print $1 }' | tr -d '\n' | cb
}

# fgc - fuzzy git checkout branch
fgc() {
  git branch --format='%(refname:short) %09 %(committername) %09 %(committerdate:format:%Y/%m/%d %H:%M) %09 %(objectname:short)' | column -ts $'\t' | fzf | awk '{ print $1 }' | xargs -I % git checkout %
}

# fgh - fuzzy git hash copy
fgh() {
  local commits commit
  commits=$(git log --oneline) &&
  commit=$(echo "$commits" | fzf --preview "git show {1} | delta --no-gitconfig") &&
  $(echo "$commit" | awk '{print $1}' | tr -d '\n' | cb)
}

# fghd - fuzzy git hash diff copy
fghd() {
  local commits commit1 commit2
  commits=$(git log --oneline) &&
  commit1=$(echo "$commits" | fzf | awk '{print $1}') &&
  commit2=$(echo "$commits" | fzf --preview "git diff "$commit1...{1}" | delta --no-gitconfig" | awk '{print $1}') &&
  git diff "$commit1...$commit2" | delta &&
  $(echo "$commit1...$commit2" | tr -d '\n' | cb)
}

# fnr - fuzzy npm run
fnr() {
  local script
  script=$(cat package.json | jq -r '.scripts | to_entries[] | [.key,.value] | @csv' | column -t -s, | fzf | awk '{print $1}' | tr -d '"') &&
  if [ -n "$script" ]; then
    npm run $script
  fi
}

# fz - fuzzy z command
#fz() {
#  local res=$(z | sort -rn | cut -c 12- | fzf)
#  if [ -n "$res" ]; then
#      cd $res
#  else
#      return 1
#  fi
#}

#--------------------------------------------------------------
# zsh widget
#--------------------------------------------------------------

# ctrl + dでtmux pop windowでgitui起動
_gitui() {
  tmux popup -xC -yC -w95% -h95% -E -d "#{pane_current_path}" gitui
}
zle -N _gitui
bindkey "^D" _gitui

# ctrl + nでnnn起動
_nnn() {
  BUFFER='nnn -dHUx'
  zle accept-line
}
zle -N _nnn
bindkey "^N" _nnn

# ctrl + yでyazi起動
_yazi() {
  tmux popup -xC -yC -w95% -h95% -E -d "#{pane_current_path}" yazi
}
zle -N _yazi
bindkey "^Y" _yazi

# ctrl + gでtmux pop windowでnavi widgetを呼び出し
_custom_navi_widget() {
  tmux popup -xC -y "#{popup_pane_bottom}" -d "#{pane_current_path}" -w95% -h40% -E '\
    window=$(tmux display -p -F "#S:#I.#P") && \
    export FZF_DEFAULT_OPTS="-m --layout=reverse --border" && \
    # [-b:buffer name][-d:delete buffer][-r:LFを自動で置換しない][-p:paste時にコマンドを自動で実行しない][-t:target pane]
    TMP_BUFFER=$(navi --print | tr "\n" " ") && \
    TMP_BUFFER=${TMP_BUFFER%"${TMP_BUFFER##*[![:space:]]}"} && \ #後方の空白文字を削除
    TMP_BUFFER=${TMP_BUFFER#"${TMP_BUFFER%%[![:space:]]*}"} && \ #前方の空白文字を削除
    TMP_BUFFER=$(echo "$TMP_BUFFER" | sed -e "s/  */ /g") && \ #複数の連続した空白を1つにする
    tmux set-buffer -b tmp "$TMP_BUFFER" && \
    tmux paste-buffer -drp -t $window -b tmp \
  '
}
zle -N _custom_navi_widget
bindkey '^G' _custom_navi_widget

# ctrl + q → ctrl + qでtmux pop windowでnaviに登録されたpipe commandのsnippet呼び出し
_navi_insert_pipe_snippet() {
  local word
  tmux popup -xC -y "#{popup_pane_bottom}" -d "#{pane_current_path}" -w95% -h40% -E '\
    export FZF_DEFAULT_OPTS="-m --layout=reverse --border" && \
    TMP_BUFFER=$(navi --print --query "shell:pipe-command " | tr "\n" " ") && \
    TMP_BUFFER=${TMP_BUFFER%"${TMP_BUFFER##*[![:space:]]}"} && \ #後方の空白文字を削除
    TMP_BUFFER=${TMP_BUFFER#"${TMP_BUFFER%%[![:space:]]*}"} && \ #前方の空白文字を削除
    TMP_BUFFER=$(echo "$TMP_BUFFER" | sed -e "s/  */ /g") && \ #複数の連続した空白を1つにする
    tmux set-buffer -b tmp "$TMP_BUFFER" \
  '
  if tmux show-buffer -b tmp > /dev/null 2>&1 ; then
    word=$(tmux show-buffer -b tmp)
  fi && \
  if [ -n "$word" ] ; then
    if [[ $word =~ ">" ]] ; then
      BUFFER="$BUFFER $word"
      CURSOR=$#BUFFER #カーソルを末尾に移動
    else
      BUFFER="$BUFFER | $word"
      CURSOR=$#BUFFER #カーソルを末尾に移動
    fi
  fi && \
  tmux delete-buffer -b tmp
}
zle -N _navi_insert_pipe_snippet
bindkey '^Q^Q' _navi_insert_pipe_snippet

# ctrl + q → ctrl + aで余分な空白を削除
_delete_space() {
  local TMP_BUFFER
  TMP_BUFFER=$BUFFER
  TMP_BUFFER=${TMP_BUFFER%"${TMP_BUFFER##*[![:space:]]}"} #後方の空白文字を削除
  TMP_BUFFER=${TMP_BUFFER#"${TMP_BUFFER%%[![:space:]]*}"} #前方の空白文字を削除
  TMP_BUFFER=$(echo "$TMP_BUFFER" | sed -e 's/  */ /g') #複数の連続した空白を1つにする
  BUFFER=$TMP_BUFFER
  zle redisplay
}
zle -N _delete_space
bindkey '^Q^A' _delete_space

# ctrl + q → ctrl + zでコマンド履歴を選択して出力
_fzf_insert_command() {
  local num command line array1 array2 word
  command=$(cat <(echo "$BUFFER") <(history -100000 | cut -f 4- -d " " | tail -r) | fzf)
  if [ -n "$command" ] ; then
    BUFFER="$BUFFER $command"
    CURSOR=$#BUFFER #カーソルを末尾に移動
  fi
  zle redisplay
}
zle -N _fzf_insert_command
bindkey '^Q^Z' _fzf_insert_command

# ctrl + q → ctrl + xでコマンド履歴からwordを選択して出力
_fzf_insert_command_word() {
  local num command line array1 array2 word
  command=$(cat <(echo "$BUFFER") <(history -100000 | cut -f 4- -d " " | tail -r) | fzf)
  if [ -n "$command" ] ; then
    for i in $(seq $(echo "$command" | wc -m)) ; do
      array1+=( "$(cut -c $i- <(echo $command))\n" )
    done
  fi
  if [ -n "${array1[*]}" ] ; then
    line=$(echo -e "${array1[@]}" | fzf)
    num=$(echo "$line" | wc -m)
    for j in $(seq $num) ; do
      array2+=( "$(cut -c -$((num-j+1)) <(echo $line))\n" )
    done
  fi
  if [ -n "${array2[*]}" ] ; then
    word=$(echo -e "${array2[@]}" | fzf)
    word=${word#"${word%%[![:space:]]*}"} #前方の空白文字を削除
    word=${word%"${word##*[![:space:]]}"} #後方の空白文字を削除
    word=$(echo "$word" | tr -d '\n')
  fi
  if [ -n "$word" ] ; then
    BUFFER="$BUFFER $word"
    CURSOR=$#BUFFER #カーソルを末尾に移動
  fi
  zle redisplay
}
zle -N _fzf_insert_command_word
bindkey '^Q^X' _fzf_insert_command_word

# ctrl + q → ctrl + wで画面キャプチャしてwordを選択してコピー
_copy_word() {
  local num line1 line2 array1 array2 word
  line1=$(tmux capture-pane -p | fzf)
  if [ -n "$line1" ] ; then
    for i in $(seq $(echo "$line1" | wc -m)) ; do
      array1+=( "$(cut -c $i- <(echo $line1))\n" )
    done
  fi
  if [ -n "${array1[*]}" ] ; then
    line2=$(echo -e "${array1[@]}" | fzf)
    num=$(echo "$line2" | wc -m)
    for j in $(seq $num) ; do
      array2+=( "$(cut -c -$((num-j+1)) <(echo $line2))\n" )
    done
  fi
  if [ -n "${array2[*]}" ] ; then
    word=$(echo -e "${array2[@]}" | fzf)
    word=${word%"${word##*[![:space:]]}"} #後方の空白文字を削除
    word=${word#"${word%%[![:space:]]*}"} #前方の空白文字を削除
  fi
  if [ -n "$word" ] ; then
    echo "$word" | tr -d '\n' | cb
  fi
  zle redisplay
}
zle -N _copy_word
bindkey '^Q^W' _copy_word

# ctrl + q → ctrl + gでtmux pop windowでnaviのコマンドをクリップボードにコピー
_navi_copy_snippet() {
  tmux popup -xC -y "#{popup_pane_bottom}" -d "#{pane_current_path}" -w95% -h40% -E '\
    export FZF_DEFAULT_OPTS="-m --layout=reverse --border" && \
    # [-b:buffer name][-d:delete buffer][-r:LFを自動で置換しない][-p:paste時にコマンドを自動で実行しない][-t:target pane]
    TMP_BUFFER=$(navi --print | tr "\n" " ") && \
    TMP_BUFFER=${TMP_BUFFER%"${TMP_BUFFER##*[![:space:]]}"} && \ #後方の空白文字を削除
    TMP_BUFFER=${TMP_BUFFER#"${TMP_BUFFER%%[![:space:]]*}"} && \ #前方の空白文字を削除
    TMP_BUFFER=$(echo "$TMP_BUFFER" | sed -e "s/  */ /g") && \ #複数の連続した空白を1つにする
    tmux set-buffer -b tmp "$TMP_BUFFER" \
  '
  if tmux show-buffer -b tmp > /dev/null 2>&1 ; then
    tmux show-buffer -b tmp | cb
  fi && \
  tmux delete-buffer -b tmp
}
zle -N _navi_copy_snippet
bindkey '^Q^G' _navi_copy_snippet

# option + ↑で１つ上のディレクトリに移動
_cd-up () {
  BUFFER='cd ../'
  zle accept-line
}
zle -N _cd-up
bindkey '^[[1;3A' _cd-up

autoload -U modify-current-argument
# Esc + sで単語を''で囲む
_quote-previous-word-in-single() {
    modify-current-argument '${(qq)${(Q)ARG}}'
    zle vi-forward-blank-word
}
zle -N _quote-previous-word-in-single
bindkey '^[s' _quote-previous-word-in-single

# Esc + dで単語を""で囲む
_quote-previous-word-in-double() {
    modify-current-argument '${(qqq)${(Q)ARG}}'
    zle vi-forward-blank-word
}
zle -N _quote-previous-word-in-double
bindkey '^[d' _quote-previous-word-in-double

#--------------------------------------------------------------
# function
#--------------------------------------------------------------

function ssh() {
  # tmux起動時
  if [[ -n $(printenv TMUX) ]] ; then
    # 接続先ホスト名に応じて背景色切り替え
    if [[ `echo "$1" | grep 'audit'` ]] ; then
      tmux set -p window-active-style 'bg=#400000'
      tmux set -p window-style 'bg=#400000'
    else
      tmux set -p window-active-style 'bg=#002800'
      tmux set -p window-style 'bg=#002800'
    fi

    command ssh $@
    # 色設定を戻す
    tmux set -p window-style 'bg=#303030'
    tmux set -p window-active-style 'bg=#000000'
  else
    command ssh $@
  fi
}

#--------------------------------------------------------------
# other
#--------------------------------------------------------------
# historyの保存先
export NODE_REPL_HISTORY="$HOME/.local/state/node/.node_repl_history"
export SQLITE_HISTORY="$HOME/.local/state/sqlite/.sqlite_history"
export MYSQL_HISTFILE="$HOME/.local/state/mysql/.mysql_history"
export PSQL_HISTORY="$HOME/.local/state/psql/.psql_history"
export LESSHISTFILE="$HOME/.local/state/less/.lesshst"

# pyenv setting
#export PYENV_ROOT="$HOME/.pyenv"
#export PATH="$PYENV_ROOT/bin:$PATH"
#if command -v pyenv 1>/dev/null 2>&1; then
#  eval "$(pyenv init -)"
#fi

# nodenv setting
#eval "$(nodenv init -)"
#export PATH="$(npm root -g):$PATH"

# .zshrc.secretの読込
ZSH_SECRET_CONF="${HOME}/.zshrc.secret"
if [ -e "${ZSH_SECRET_CONF}" ]; then
  source "${ZSH_SECRET_CONF}"
fi

# 補完の読込
autoload -Uz compinit
autoload -Uz _zinit
(( ${+_comps} )) && _comps[zinit]=_zinit

{{ if eq .chezmoi.os "darwin" -}}
if [ $(date +'%j') != $(/usr/bin/stat -f '%Sm' -t '%j' ~/.zcompdump) ]; then
  compinit
else
  compinit -C
fi
{{- else -}}
compinit
{{- end }}

# zprofでのプロファイル測定用
if (which zprof > /dev/null 2>&1) ;then
  zprof
fi
